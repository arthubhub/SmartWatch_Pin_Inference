# Communication Protocol Documentation

## Binary Frame Format (Arduino → PC)

### Frame Structure (54 bytes, little-endian)

| Offset | Size | Type    | Name            | Description                                  |
|--------|------|---------|-----------------|----------------------------------------------|
| 0      | 4    | uint32  | magic           | Frame sync marker: `0xA1B2C3D4`              |
| 4      | 4    | uint32  | seq             | Monotonic sequence number                    |
| 8      | 8    | uint64  | tick_us         | Arduino microsecond timestamp                |
| 16     | 2    | int16   | ax_raw          | Accel X raw ADC (0-1023)                     |
| 18     | 2    | int16   | ay_raw          | Accel Y raw ADC (0-1023)                     |
| 20     | 2    | int16   | az_raw          | Accel Z raw ADC (0-1023)                     |
| 22     | 2    | int16   | gp_raw          | Gyro pitch raw ADC (0-1023)                  |
| 24     | 2    | int16   | gy_raw          | Gyro yaw raw ADC (0-1023)                    |
| 26     | 4    | float32 | ax_g            | Calibrated accel X (g)                       |
| 30     | 4    | float32 | ay_g            | Calibrated accel Y (g)                       |
| 34     | 4    | float32 | az_g            | Calibrated accel Z (g)                       |
| 38     | 4    | float32 | pitch_rate      | Angular rate pitch (deg/s)                   |
| 42     | 4    | float32 | yaw_rate        | Angular rate yaw (deg/s)                     |
| 46     | 4    | float32 | pitch_filtered  | Complementary filtered pitch angle (deg)     |
| 50     | 4    | float32 | roll_filtered   | Complementary filtered roll angle (deg)      |

**Total frame size: 54 bytes**

### Frame Rate
- **200 Hz** (5 ms interval)
- Generated by Timer1 ISR on Arduino
- Timing jitter: < 100 µs typical

### Example Frame (hex)

```
D4 C3 B2 A1              // magic (0xA1B2C3D4)
2A 00 00 00              // seq = 42
40 42 0F 00 00 00 00 00  // tick_us = 1000000
FF 01                    // ax_raw = 511 (accel X ADC)
00 02                    // ay_raw = 512 (accel Y ADC)
01 02                    // az_raw = 513 (accel Z ADC)
FE 01                    // gp_raw = 510 (gyro pitch ADC)
02 02                    // gy_raw = 514 (gyro yaw ADC)
... (28 bytes of float32 calibrated values) ...
```

Total frame size: **58 bytes**

**Float32 values** (IEEE 754 format, little-endian):
- ax_g, ay_g, az_g: Calibrated acceleration in g
- pitch_rate, yaw_rate: Angular rates in deg/s
- pitch_filtered, roll_filtered: Filter-estimated angles in deg

## Serial Sync Protocol

### Sync Command (PC → Arduino)

**Format**: `SYNC` (4 ASCII bytes) + `timestamp` (8 bytes, uint64, nanoseconds)

```
Bytes:  S Y N C [t_server_ns as little-endian uint64]
Hex:    53 59 4E 43 [8 bytes timestamp]
```

**Frequency**: Every 1-2 seconds

### Sync Response (Arduino → PC)

1. Arduino marks next frame as sync frame
2. Frame sent with normal binary format (58 bytes)
3. Followed by: `# SYNC_ACK\n` (ASCII text)

**Example**:
```
[58 bytes binary frame]
# SYNC_ACK
```

### Time Mapping

Server maintains linear model: `t_server_ns = offset + drift_rate × tick_us`

**Procedure**:
1. Collect sync points: `(tick_us, t_server_ns)` pairs
2. Keep 60-second sliding window
3. Linear regression every sync cycle
4. Apply mapping to all frames

**Quality metrics**:
- **Residual < 10 ms**: Good sync
- **Residual > 10 ms**: Warning (USB issues, system load)

## WebSocket Protocol (Browser ↔ Server)

### Message Format

All messages are JSON objects with required `event` field.

### Client → Server Messages

#### 1. Join Session
```json
{
  "event": "join_session",
  "subject_id": "subject001",
  "session_id": "session_20241103_140530",
  "mode": "train"
}
```

**Response**:
```json
{
  "event": "ack",
  "t_server_ns": 1699024800000000000,
  "session": {
    "subject_id": "subject001",
    "session_id": "session_20241103_140530",
    "mode": "train",
    "sequences": 0,
    "events": 0
  }
}
```

#### 2. Start Sequence
```json
{
  "event": "start_sequence",
  "sequence_id": "seq_1699024800_abc123",
  "pin_string": "1234"
}
```

**Note**: `pin_string` only included in **train** mode.

**Response**:
```json
{
  "event": "ack",
  "t_server_ns": 1699024800500000000,
  "sequence_id": "seq_1699024800_abc123"
}
```

#### 3. Digit Event
```json
{
  "event": "digit",
  "sequence_id": "seq_1699024800_abc123",
  "digit": 5,
  "edge": "down",
  "t_client_ms": 1699024800123
}
```

**Fields**:
- `digit`: 0-9
- `edge`: `"down"` (press) or `"up"` (release)
- `t_client_ms`: Client-side timestamp (milliseconds since epoch)

**Response**:
```json
{
  "event": "ack",
  "t_server_ns": 1699024800600000000,
  "sequence_id": "seq_1699024800_abc123",
  "digit": 5,
  "edge": "down"
}
```

#### 4. End Sequence
```json
{
  "event": "end_sequence",
  "sequence_id": "seq_1699024800_abc123"
}
```

**Response (train mode)**:
```json
{
  "event": "ack",
  "t_server_ns": 1699024805000000000,
  "sequence_id": "seq_1699024800_abc123"
}
```

**Response (test mode)**:
```json
{
  "event": "ack",
  "t_server_ns": 1699024805000000000,
  "sequence_id": "seq_1699024800_abc123",
  "prediction": "(feature needs to be added)"
}
```

#### 5. Ping
```json
{
  "event": "ping",
  "t_client_ms": 1699024800123
}
```

**Response**:
```json
{
  "event": "pong",
  "t_server_ns": 1699024800200000000,
  "rtt_ms": 12.5
}
```

**Frequency**: Every 2 seconds (automatic)

### Server → Client Messages

#### Status Message
```json
{
  "event": "status",
  "ok": true,
  "msg": "Connected to server"
}
```

**Types**:
- `ok: true` - Info/success
- `ok: false` - Error

## Data Storage Format

### Parquet Schema Definitions

#### IMU Data Table

```python
schema = pa.schema([
    ('t_ns', pa.int64()),               # Server-aligned timestamp
    ('seq', pa.int32()),                # Frame sequence number
    # Raw ADC values (for debugging)
    ('ax_raw', pa.int16()),             # Accel X raw ADC
    ('ay_raw', pa.int16()),             # Accel Y raw ADC
    ('az_raw', pa.int16()),             # Accel Z raw ADC
    ('gp_raw', pa.int16()),             # Gyro pitch raw ADC
    ('gy_raw', pa.int16()),             # Gyro yaw raw ADC
    # Calibrated physical values
    ('ax_g', pa.float32()),             # Accel X (g)
    ('ay_g', pa.float32()),             # Accel Y (g)
    ('az_g', pa.float32()),             # Accel Z (g)
    ('pitch_rate', pa.float32()),       # Pitch rate (deg/s)
    ('yaw_rate', pa.float32()),         # Yaw rate (deg/s)
    ('pitch_filtered', pa.float32()),   # Filtered pitch (deg)
    ('roll_filtered', pa.float32()),    # Filtered roll (deg)
    # Metadata
    ('tick_us', pa.int64()),            # Arduino timestamp
    ('subject_id', pa.string()),        # Subject ID
    ('session_id', pa.string()),        # Session ID
])
```

**File naming**: `imu_{subject_id}_{session_id}_{timestamp}.parquet`

**Rotation policy**: New file every 256 MB or 30 minutes

#### Events Table (JSON)

```json
{
  "t_ns": 1699024800600000000,
  "sequence_id": "seq_1699024800_abc123",
  "digit": 5,
  "edge": "down",
  "t_client_ms": 1699024800123,
  "subject_id": "subject001",
  "session_id": "session001",
  "mode": "train",
  "rtt_ms": 12.5
}
```

**File**: `{subject_id}/{session_id}/events.json`

#### Sequences Table (JSON)

```json
{
  "sequence_id": "seq_1699024800_abc123",
  "mode": "train",
  "pin_string": "1234",
  "subject_id": "subject001",
  "session_id": "session001",
  "trial_idx": 0,
  "keypad_layout": "3x4",
  "t_start_ns": 1699024800000000000,
  "t_end_ns": 1699024805000000000,
  "notes": ""
}
```

**File**: `{subject_id}/{session_id}/sequences.json`

**Note**: `pin_string` is `null` in **test** mode.

## Calibration Protocol

### Gyroscope Zero-Rate Calibration (Automatic)

Performed automatically at every Arduino startup.

**Procedure**:
1. Arduino powers up
2. Takes 1000 samples over ~0.5 seconds
3. Computes average ADC value for each gyro axis
4. These become zero-rate baselines

**User requirement**: Keep sensor stationary during startup.

**Continuous recalibration**:
- During operation, if angular rate < 0.3 deg/s for sustained period
- Zero-rate offset slowly adapts (alpha = 0.001)
- Compensates for temperature drift

### Accelerometer Calibration (Pre-configured)

The firmware uses **factory calibration** based on measured characteristics:

```cpp
// Your measured values (volts)
ACCEL_OFFSET_X_V = 1.096  // Zero-g offset
ACCEL_OFFSET_Y_V = 1.093
ACCEL_OFFSET_Z_V = 1.106

ACCEL_SENS_X_V_PER_G = 0.2207  // Sensitivity
ACCEL_SENS_Y_V_PER_G = 0.2236
ACCEL_SENS_Z_V_PER_G = 0.2227
```

No runtime calibration needed unless sensor is replaced.

### Complementary Filter Configuration

```cpp
ALPHA = 0.98  // 98% gyroscope, 2% accelerometer
```

**Filter equations**:
```
pitch_filtered = alpha * (pitch_prev + pitch_rate * dt) + (1-alpha) * pitch_accel
roll_filtered = alpha * (roll_prev + yaw_rate * dt) + (1-alpha) * roll_accel
```

Where:
- `pitch_accel = atan2(ay, sqrt(ax^2 + az^2))` 
- `roll_accel = atan2(-ax, az)`

### Calibration Computation (Post-Collection)

**Accelerometer verification** (calibration already applied):
```python
# Verify calibrated values are correct
stationary_data = df[stationary_mask]

ax_mean = stationary_data['ax_g'].mean()
ay_mean = stationary_data['ay_g'].mean()  
az_mean = stationary_data['az_g'].mean()

magnitude = np.sqrt(ax_mean**2 + ay_mean**2 + az_mean**2)
print(f"Acceleration magnitude: {magnitude:.3f} g")
# Should be ~1.0g when stationary

error_percent = abs(magnitude - 1.0) * 100
if error_percent < 5:
    print("Calibration: Excellent")
elif error_percent < 10:
    print("Calibration: Acceptable")
else:
    print("Calibration: Poor - consider recalibration")
```

**Gyroscope verification**:
```python
# Check zero-rate bias
stationary_data = df[stationary_mask]

pitch_bias = stationary_data['pitch_rate'].mean()
yaw_bias = stationary_data['yaw_rate'].mean()

print(f"Pitch bias: {pitch_bias:.3f} deg/s")
print(f"Yaw bias: {yaw_bias:.3f} deg/s")
# Should be < 0.5 deg/s for good calibration
```

**Complementary filter verification**:
```python
# Check that filtered angles don't drift
time_sec = df['t_ns'] / 1e9
pitch = df['pitch_filtered']
roll = df['roll_filtered']

# Compute drift rate during stationary period
pitch_drift = (pitch.iloc[-1] - pitch.iloc[0]) / (time_sec.iloc[-1] - time_sec.iloc[0])
roll_drift = (roll.iloc[-1] - roll.iloc[0]) / (time_sec.iloc[-1] - time_sec.iloc[0])

print(f"Pitch drift: {pitch_drift:.3f} deg/s")
print(f"Roll drift: {roll_drift:.3f} deg/s")
# Should be < 0.1 deg/s
```

## Timing Specifications

### Arduino Timing

- **Sample rate**: 200 Hz ± 0.1 Hz
- **ISR duration**: < 400 µs (5 ADC channels + filter computation)
- **ADC conversion**: ~100 µs per channel (5 total = 500 µs)
- **Filter computation**: ~50 µs (complementary filter math)
- **Serial transmission**: 58 bytes @ 115200 baud ≈ 5 ms
- **Timer jitter**: < 100 µs

### Network Timing

- **WebSocket latency**: 5-50 ms typical (local network)
- **RTT measurement**: Via ping/pong every 2 seconds
- **Event timestamp precision**: 1 ms (JavaScript `Date.now()`)

### Time Alignment

- **Arduino clock**: `micros()` (1 µs resolution, wraps at ~70 minutes)
- **Server clock**: `time.time_ns()` (1 ns resolution, system clock)
- **Sync precision**: < 10 ms typical, < 1 ms achievable with good USB
- **Client-server offset**: Logged via `rtt_ms` but not corrected (use server stamps)

## Error Handling

### Arduino Errors

**Frame corruption**:
- Detection: Magic number mismatch
- Recovery: Discard bytes until next magic found
- Log: "Warning: Discarded X bytes"

**Sequence gaps**:
- Detection: `seq` not monotonic
- Recovery: Continue (data still usable)
- Log: Frame drop count

### Serial Errors

**Connection loss**:
- Detection: Serial timeout (1 second)
- Recovery: Reconnection attempt
- Data: Marked as gap in timeline

**Sync timeout**:
- Detection: No SYNC_ACK within 500 ms
- Recovery: Skip this sync, try next cycle
- Impact: Slight time drift until next successful sync

### WebSocket Errors

**Connection loss**:
- Detection: Socket disconnect event
- Recovery: Client auto-reconnects
- Data: Session state preserved on server

**Out-of-order messages**:
- Detection: Sequence ID validation
- Recovery: Accept late messages (all timestamped)
- Impact: None (timestamps resolve order)

## Data Quality Checks

### Runtime Checks

1. **Frame rate**: Should be 200 ± 1 Hz
2. **Sync residual**: Should be < 10 ms RMS
3. **Event-IMU alignment**: Digit events should precede IMU peaks by 0-100 ms
4. **Sequence completeness**: Each sequence should have start/end + 4-digit events

### Post-Collection Validation

```python
# Check IMU frame rate
dt = np.diff(imu_df['t_ns']) / 1e9  # Convert to seconds
assert np.abs(dt.mean() - 0.005) < 0.0001, "Frame rate drift"

# Check for frame drops
seq_diff = np.diff(imu_df['seq'])
drops = np.sum(seq_diff != 1)
assert drops < 10, f"Too many frame drops: {drops}"

# Check event-sequence correspondence
for seq in sequences:
    events = events_df[events_df['sequence_id'] == seq['sequence_id']]
    assert len(events) >= 8, "Missing events (need 4 down + 4 up)"
```

## Version History

- **v1.0** (2024-11-03): Initial protocol definition
  - Binary frame format
  - Time sync via linear regression
  - WebSocket event protocol
  - Parquet storage schema